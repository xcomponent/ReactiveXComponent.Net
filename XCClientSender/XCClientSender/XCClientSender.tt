<#@ template debug="true" hostSpecific="true" language="C#"#>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ Assembly Name="System.Xml" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
//Autogenerated File
<#
//Open XML File
var doc = new XmlDocument();	
var xmlmanager = new XmlNamespaceManager(doc.NameTable);
xmlmanager.AddNamespace("xc", "http://xcomponent.com/DeploymentConfig.xsd");
doc.Load(_xmlFile);//this.Host.ResolvePath(_xmlFile));//"OrderProcessing.xcApi"));
#>

<#
var Components = doc.SelectNodes("//xc:component", xmlmanager);
var stateMachines = doc.SelectNodes("//xc:stateMachines", xmlmanager);
var subscribeNodes = doc.SelectNodes("//xc:subscribe[@eventType='UPDATE']", xmlmanager);
var publishNodes = doc.SelectNodes("//xc:publish", xmlmanager);
var states = doc.SelectNodes("//xc:states", xmlmanager);
#>

using System;
using XCClientLib.Builder;
using XCClientLib.Common;
using XCClientLib.RabbitMQ;

namespace XCClientLib
{
	public class XClientSender : IDisposable
	{
		private IXComponentApi iApi;
		private string deploymentFile;

<#
string componentName = "";
string componentType = "";

foreach(System.Xml.XmlElement Component in Components)
{
	componentType = Component.Attributes["name"].Value + "_Component";

#>		public <#=componentType#> <#=componentType#> { get; protected set; }
<#
}
#>		
		public XClientSender(string deploymentFile)
		{
			this.deploymentFile = deploymentFile;
<#
foreach(System.Xml.XmlElement Component in Components)
{
	componentType = Component.Attributes["name"].Value + "_Component";
#>
			<#=componentType#> =  new <#=componentType#>();
<#			

}
#>	
		}		
		
		public void Init()
		{
			XComponentBuilder xcBuilder = new XComponentBuilder(this.deploymentFile);
			iApi = xcBuilder.CreateApi();
<#
//Dictionary containing state machines by component
int i =0;
Dictionary<System.Xml.XmlElement, List < System.Xml.XmlElement > > StateMachinesByComponent = new Dictionary<XmlElement, List<XmlElement>>();
foreach (System.Xml.XmlElement Component in Components)
{	
	StateMachinesByComponent.Add(Component, new List<System.Xml.XmlElement>());
    foreach (System.Xml.XmlElement StateMachine in stateMachines[i])
    {
        StateMachinesByComponent[Component].Add(StateMachine);
    }
    i++;
}
ImplementApiClass(StateMachinesByComponent, subscribeNodes);
#>
		
		public void InitTopic(string privateCommunicationIdentifier){
			XComponentApi.PrivateCommunicationIdentifier = privateCommunicationIdentifier;
		}

		public void Dispose() {
			iApi.Dispose();
		}	
<#
DeclareSendAction(StateMachinesByComponent,  publishNodes, xmlmanager);
DeclareComponentInterface(StateMachinesByComponent, subscribeNodes); 
DeclareComponentClass(StateMachinesByComponent, subscribeNodes); 
DeclareStateMachineInterface(StateMachinesByComponent, subscribeNodes);
DeclareStateMachineClass(StateMachinesByComponent, subscribeNodes);
EndSpaceBlock(); 
#>

<#+
private void ImplementApiClass(Dictionary<System.Xml.XmlElement, List < System.Xml.XmlElement > > StateMachinesByComponent, XmlNodeList subscribeNodes){
		string componentName;
		string componentType;
		string communicationType;
		string stateMachineName;
		string stateMachineType;
		string stateMachineCode;
		string methodName;
		string eventName;

        foreach (var element in StateMachinesByComponent)
        {
            componentName = element.Key.Attributes["name"].Value;
            componentType = componentName + "_Component";
            foreach (var StateMachine in element.Value)
            {
                stateMachineName = StateMachine.Attributes["name"].Value;
                stateMachineType = StateMachine.Attributes["name"].Value + "_StateMachine";
                foreach (XmlNode subscribeNode in subscribeNodes)
                {
                    communicationType = subscribeNode.Attributes["communicationType"].InnerText;
                    if (communicationType == "IN_MEMORY")
                        continue;

                    eventName = subscribeNode.Attributes["event"].InnerText;
                    stateMachineCode = subscribeNode.Attributes["stateMachineCode"].Value;
                    if (stateMachineCode == StateMachine.Attributes["id"].Value
                        && eventName != string.Empty)
                    {
                        eventName = eventName.Split('.').Last();
                        methodName = "On" + (eventName).ToString() + stateMachineName + "InstanceUpdated";
#>			iApi.AddCallback("<#=componentName#>","<#=stateMachineName#>",<#=componentType#>.<#=stateMachineType#>.<#=methodName#>);
<#+					}
				}
			
			}
		}
#>
		}
<#+
}

private void DeclareComponentInterface(Dictionary<System.Xml.XmlElement, List < System.Xml.XmlElement > > StateMachinesByComponent, XmlNodeList subscribeNodes)
{ 
	string componentName;
	string stateMachineType;
	string stateMachineCode;
	string eventName;

	foreach (var element in StateMachinesByComponent)
	{
		componentName = element.Key.Attributes["name"].Value +"_Component" ;
#>	
	public interface I<#=componentName#> 
	{
<#+
		foreach (var StateMachine in element.Value)
        {
			stateMachineType = StateMachine.Attributes["name"].Value + "_StateMachine";
			
			foreach (XmlNode subscribeNode in subscribeNodes)
			{
				eventName = subscribeNode.Attributes["event"].InnerText;
				stateMachineCode = subscribeNode.Attributes["stateMachineCode"].Value;
				if (stateMachineCode == StateMachine.Attributes["id"].Value
					&& eventName != string.Empty) {
				
#>		<#=stateMachineType#> <#=stateMachineType#> { get; set; }
<#+			
				}
			}
		}
#>	}
<#+
	}
}
private void DeclareComponentClass(Dictionary<System.Xml.XmlElement, List < System.Xml.XmlElement > > StateMachinesByComponent, XmlNodeList subscribeNodes)
{ 
	string componentName;
	string stateMachineType;
	string stateMachineCode;
	string eventName;

	foreach (var element in StateMachinesByComponent)
	{
		componentName = element.Key.Attributes["name"].Value +"_Component" ;

#>	
	sealed public class <#=componentName#> : I<#=componentName#> 
	{
<#+
		foreach (var StateMachine in element.Value)
        {
			stateMachineType = StateMachine.Attributes["name"].Value + "_StateMachine";
			
			foreach (XmlNode subscribeNode in subscribeNodes)
			{
				eventName = subscribeNode.Attributes["event"].InnerText;
				stateMachineCode = subscribeNode.Attributes["stateMachineCode"].Value;
				if (stateMachineCode == StateMachine.Attributes["id"].Value
					&& eventName != string.Empty) 
				{
#>		public <#=stateMachineType#> <#=stateMachineType#> { get; set; }
<#+ 
				}
			}
		}
#>

		public <#=componentName#>(){
<#+
		foreach (var StateMachine in element.Value)
        {
			stateMachineType = StateMachine.Attributes["name"].Value + "_StateMachine";
			
			foreach (XmlNode subscribeNode in subscribeNodes)
			{
				eventName = subscribeNode.Attributes["event"].InnerText;
				stateMachineCode = subscribeNode.Attributes["stateMachineCode"].Value;
				if (stateMachineCode == StateMachine.Attributes["id"].Value
					&& eventName != string.Empty) 
				{
#>			<#=stateMachineType#> = new <#=stateMachineType#>();
<#+ 
				}
			}		
		}			
#>		}
	}
<#+
	}
}

private void DeclareStateMachineInterface(Dictionary<System.Xml.XmlElement, List<System.Xml.XmlElement>> StateMachinesByComponent, XmlNodeList subscribeNodes)
{ 
	string stateMachineType;
	string stateMachineName;
	string stateMachineCode;
	string communicationType;
	string eventName;
	string eventNameFirst;
	string eventNameSecond;
	string methodName;
	
	foreach (var element in StateMachinesByComponent)
	{
		foreach (var StateMachine in element.Value)
        {
			stateMachineType = StateMachine.Attributes["name"].Value + "_StateMachine";
			stateMachineName = StateMachine.Attributes["name"].Value;
		
			foreach (XmlNode subscribeNode in subscribeNodes)
			{
				communicationType = subscribeNode.Attributes["communicationType"].InnerText;
				if (communicationType == "IN_MEMORY")
					continue;
				
				eventName = subscribeNode.Attributes["event"].InnerText;
				stateMachineCode = subscribeNode.Attributes["stateMachineCode"].Value;
				if (stateMachineCode == StateMachine.Attributes["id"].Value
					&& eventName != string.Empty) 
				{
					methodName = eventName.Split('.').Last() + stateMachineName; 
#>	
	public interface I<#=stateMachineType#> 
	{
		event System.Action<<#=eventName#>> <#=methodName#>;
		void On<#=methodName#>InstanceUpdated(MessageEventArgs busEvent); 
<#+
				
					endBlock();
				}
			}
		}
	}
}

private void DeclareStateMachineClass(Dictionary<System.Xml.XmlElement, List<System.Xml.XmlElement>> StateMachinesByComponent, XmlNodeList subscribeNodes)
{ 
	string stateMachineType;
	string stateMachineName;
	string stateMachineCode; 
	string communicationType;
	string eventName;
	string methodName;

	foreach (var element in StateMachinesByComponent)
	{
		foreach (var StateMachine in element.Value)
        {
			stateMachineType = StateMachine.Attributes["name"].Value + "_StateMachine";
			stateMachineName = StateMachine.Attributes["name"].Value;
		
			foreach (XmlNode subscribeNode in subscribeNodes)
			{
				communicationType = subscribeNode.Attributes["communicationType"].InnerText;
				if (communicationType == "IN_MEMORY")
					continue;
				
				eventName = subscribeNode.Attributes["event"].InnerText;
				stateMachineCode = subscribeNode.Attributes["stateMachineCode"].Value;
				if (stateMachineCode == StateMachine.Attributes["id"].Value
					&& eventName != string.Empty) 
				{
					methodName = eventName.Split('.').Last() + stateMachineName; 
#>	
	public sealed class <#=stateMachineType#> : I<#=stateMachineType#>
	{
		public event System.Action<<#=eventName#>> <#=methodName#>;
		public void On<#=methodName#>InstanceUpdated(MessageEventArgs busEvent) {
			if( <#=methodName#> != null ){ 
				var publicMember = busEvent.MessageReceived as <#=eventName#>;
				if( publicMember != null ) <#=methodName#>(publicMember);
			}
		}
<#+					endBlock();
				}
			}

		}
	}
}

private void DeclareSendAction(Dictionary<System.Xml.XmlElement, List<System.Xml.XmlElement>> StateMachinesByComponent, XmlNodeList  publishNodes, XmlNamespaceManager xmlmanager)
{
	string communicationType;
	string eventName;
	string eventNameFirst;
	string eventNameSecond;
	string eventNameEnd;
	string eventCode;
	string methodName;
	List<string> eventRedundancy = new List<string>();
	
	foreach (var element in StateMachinesByComponent)
	{
		string componentName = element.Key.Attributes["name"].Value;
		List<string> eventCodes = new List<string>() ;

		foreach (var StateMachine in element.Value)
        {
			foreach (XmlNode publishNode in publishNodes)
			{
				communicationType = publishNode.Attributes["communicationType"].InnerText;
				if (communicationType == "IN_MEMORY")
					continue;

				if (element.Key.Attributes["id"].Value == publishNode.Attributes["componentCode"].Value)
				{
					eventName = publishNode.Attributes["event"].InnerText;
					eventCode = publishNode.Attributes["eventCode"].InnerText;
					eventNameFirst = (eventName.Split('.')).FirstOrDefault();
					eventNameSecond = (eventName.Split('.'))[1];
					//Check if Event is called once and part of XC.Component.Userobject
					if (!eventCodes.Contains(eventCode) 
						&& eventName != string.Empty 
						&& eventNameFirst == "XComponent" && eventNameSecond != "Common") 
					{
						eventNameEnd = (eventName.Split('.')).Last();
						eventCodes.Add(eventCode);
						methodName = StateMachine.Attributes["name"].Value; 
						var runtimetmp1 = (publishNode.SelectSingleNode("xc:topic", xmlmanager).InnerXml);
						var runtimetmp2 =  runtimetmp1.Split('.');
						string runtime = runtimetmp2[runtimetmp2.Length - 3];
						//Check if same sendEvent name used if different components
						if(!eventRedundancy.Contains(eventNameEnd))
                        {
							eventRedundancy.Add(eventNameEnd);
#>		
		public void Send<#=eventNameEnd#>(<#=eventName#> obj, Visibility visibility)
		{
			iApi.SendEvent("<#=runtime#>","<#=componentName#>", "<#=methodName#>",<#=eventCode#>,"<#=eventName#>", obj, visibility);
		}
<#+
                        }
						else
						{
#>		
		public void Send<#=eventNameEnd#><#=componentName#>(<#=eventName#> obj, Visibility visibility)
		{
			iApi.SendEvent("<#=runtime#>","<#=componentName#>", "<#=methodName#>",<#=eventCode#>,"<#=eventName#>", obj, visibility);
		}
<#+
                        }
					}
				}
			}
		}
	}
#>
	}
<#+
}

private void EndSpaceBlock(){
#>
}
<#+
}
private void endBlock(){
#>
	}
<#+
}
#>