<#@ template debug="true" hostSpecific="true" language="C#"#>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Xml" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #> 
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template T4. 
//     Changes to this file may cause incorrect behavior
// </auto-generated>
// ------------------------------------------------------------------------------
<#
//Open xcApi File 
var doc = new XmlDocument();	
var xmlmanager = new XmlNamespaceManager(doc.NameTable);
xmlmanager.AddNamespace("xc", "http://xcomponent.com/DeploymentConfig.xsd");
doc.Load(_xmlFile);

//Split File in different nodes 
var components = doc.SelectNodes("//xc:component", xmlmanager);
var stateMachines = doc.SelectNodes("//xc:stateMachines", xmlmanager);
var subscribeNodes = doc.SelectNodes("//xc:subscribe[@eventType='UPDATE']", xmlmanager);
var publishNodes = doc.SelectNodes("//xc:publish", xmlmanager);
var states = doc.SelectNodes("//xc:states", xmlmanager);
#>

<# /*XCClientApi template*/ #>
using System;
using System.IO;
using ReactiveXComponent;
using ReactiveXComponent.Common;
using ReactiveXComponent.Connection;
using ReactiveXComponent.RabbitMq;

namespace XComponentClientApi
{
	public class XCClientApi
	{
		private IXComponentApi _xcApi;
		private Stream _xcApiStream;
		private IXCSession _xcSession;

<#
string componentType;

foreach(System.Xml.XmlElement component in components)
{
	componentType = component.Attributes["name"].Value + "Component";

#>		public <#=componentType#> <#=componentType#> { get; private set; }
<#
}
#>			
		public void InitApi(string deploymentFile, string privateCommunicationIdentifier = null)
		{
			_xcApiStream = new FileStream(deploymentFile, FileMode.OpenOrCreate, FileAccess.Read, FileShare.Read);
			_xcApi = XComponentApi.CreateFromXCApi(_xcApiStream, privateCommunicationIdentifier);
			_xcSession = _xcApi.CreateSession();

<#
foreach(System.Xml.XmlElement component in components)
{
	componentType = component.Attributes["name"].Value + "Component";
#>
			<#=componentType#> =  new <#=componentType#>(_xcSession);
<#			
}
#>	

			var subscriber = _xcSession.CreateSubscriber();
<#
//State machines by Component repository
Dictionary<System.Xml.XmlElement, List < System.Xml.XmlElement > > stateMachinesByComponent = new Dictionary<XmlElement, List<XmlElement>>();

foreach (System.Xml.XmlElement component in components)
{	
	stateMachinesByComponent.Add(component, new List<System.Xml.XmlElement>());
    foreach (System.Xml.XmlElement stateMachine in component.LastChild)
    {
        stateMachinesByComponent[component].Add(stateMachine);
    }
}
ImplementApiClass(stateMachinesByComponent, subscribeNodes);
#>
	}		
	
<#
DeclareComponentInterface(stateMachinesByComponent, subscribeNodes); 
DeclareComponentClass(stateMachinesByComponent, subscribeNodes); 
DeclareStateMachineInterface(stateMachinesByComponent, publishNodes,subscribeNodes);
DeclareStateMachineClass(stateMachinesByComponent, publishNodes,subscribeNodes);
EndSpaceBlock(); 
#>

<#+
private void ImplementApiClass(Dictionary<System.Xml.XmlElement, List < System.Xml.XmlElement > > stateMachinesByComponent, XmlNodeList subscribeNodes)
{		
	foreach (var element in stateMachinesByComponent)
	{
	    var componentName = element.Key.Attributes["name"].Value;
	    var componentType = componentName + "Component";
	    foreach (var stateMachine in element.Value)
	    {
	        var stateMachineName = componentName+"_"+stateMachine.Attributes["name"].Value;
	        var stateMachineType = componentName+"_"+stateMachine.Attributes["name"].Value + "StateMachine";
	        foreach (XmlNode subscribeNode in subscribeNodes)
	        {
	            var communicationType = subscribeNode.Attributes["communicationType"].InnerText;
	            if (communicationType == "IN_MEMORY")
	                continue;
	
	            var eventName = subscribeNode.Attributes["event"].InnerText;
	            var stateMachineCode = subscribeNode.Attributes["stateMachineCode"].Value;
	            if (stateMachineCode == stateMachine.Attributes["id"].Value
	                && eventName != string.Empty)
	            {
	                eventName = eventName.Split('.').Last();
	                var methodName = "On" + stateMachine.Attributes["name"].Value + "InstanceUpdated";
#>			subscriber.Subscribe("<#=componentName#>","<#=stateMachineName#>",<#=componentType#>.<#=stateMachineType#>.<#=methodName#>);
<#+				}
			}
		
		}
	}
#>
		}
<#+
}

private void DeclareComponentInterface(Dictionary<System.Xml.XmlElement, List < System.Xml.XmlElement > > stateMachinesByComponent, XmlNodeList subscribeNodes)
{ 
	foreach (var element in stateMachinesByComponent)
	{
		var componentName = element.Key.Attributes["name"].Value +"Component" ;
		var component = element.Key.Attributes["name"].Value;
#>	
	public interface I<#=componentName#> 
	{
<#+
		foreach (var stateMachine in element.Value)
        {
			var stateMachineType = component+"_"+stateMachine.Attributes["name"].Value + "StateMachine";
			
			foreach (XmlNode subscribeNode in subscribeNodes)
			{
				var eventName = subscribeNode.Attributes["event"].InnerText;
				var stateMachineCode = subscribeNode.Attributes["stateMachineCode"].Value;
				if (stateMachineCode == stateMachine.Attributes["id"].Value
					&& eventName != string.Empty) {
				
#>		<#=stateMachineType#> <#=stateMachineType#> { get; set; }
<#+			
				}
			}
		}
#>	}
<#+
	}
}
private void DeclareComponentClass(Dictionary<System.Xml.XmlElement, List < System.Xml.XmlElement > > stateMachinesByComponent, XmlNodeList subscribeNodes)
{ 

	foreach (var element in stateMachinesByComponent)
	{
		var componentName = element.Key.Attributes["name"].Value +"Component" ;
		var component = element.Key.Attributes["name"].Value;
#>	
	public class <#=componentName#> : I<#=componentName#> 
	{
<#+
		foreach (var stateMachine in element.Value)
        {
			var stateMachineType = component+"_"+stateMachine.Attributes["name"].Value + "StateMachine";
			
			foreach (XmlNode subscribeNode in subscribeNodes)
			{
				var eventName = subscribeNode.Attributes["event"].InnerText;
				var stateMachineCode = subscribeNode.Attributes["stateMachineCode"].Value;
				if (stateMachineCode == stateMachine.Attributes["id"].Value
					&& eventName != string.Empty) 
				{
#>		public <#=stateMachineType#> <#=stateMachineType#> { get; set; }
<#+ 
				}
			}
		}
#>

		public <#=componentName#>(IXCSession xcSession)
		{
			var publisher = xcSession.CreatePublisher("<#=element.Key.Attributes["name"].Value#>"); 
<#+
		foreach (var stateMachine in element.Value)
        {
			var stateMachineType = component+"_"+stateMachine.Attributes["name"].Value + "StateMachine";
			
			foreach (XmlNode subscribeNode in subscribeNodes)
			{
				var eventName = subscribeNode.Attributes["event"].InnerText;
				var stateMachineCode = subscribeNode.Attributes["stateMachineCode"].Value;
				if (stateMachineCode == stateMachine.Attributes["id"].Value
					&& eventName != string.Empty) 
				{
#>			<#=stateMachineType#> = new <#=stateMachineType#>(publisher);
<#+ 
				}
			}		
		}			
#>		}
	}
<#+
	}
}

private void DeclareStateMachineInterface(Dictionary<System.Xml.XmlElement, List<System.Xml.XmlElement>> stateMachinesByComponent, XmlNodeList publishNodes, XmlNodeList subscribeNodes)
{ 
	foreach (var element in stateMachinesByComponent)
	{
		var elem = element.Key;
		var component = elem.Attributes["name"].Value;

		foreach (var stateMachine in element.Value)
        {
			var stateMachineType =  component+"_"+stateMachine.Attributes["name"].Value + "StateMachine";
			var stateMachineName = component+"_"+stateMachine.Attributes["name"].Value;
#>	
	public interface I<#=stateMachineType#> 
	{
<#+
			DeclareSendActionInInterface(elem, stateMachine, publishNodes);
			foreach (XmlNode subscribeNode in subscribeNodes)
			{
				var communicationType = subscribeNode.Attributes["communicationType"].InnerText;
				if (communicationType == "IN_MEMORY")
					continue;
				
				var eventName = subscribeNode.Attributes["event"].InnerText;
				var stateMachineCode = subscribeNode.Attributes["stateMachineCode"].Value;
				if (stateMachineCode == stateMachine.Attributes["id"].Value
					&& eventName != string.Empty) 
				{
					var methodName = stateMachine.Attributes["name"].Value; 
#>	
		event System.Action<<#=eventName#>> <#=methodName#>;
		void On<#=methodName#>InstanceUpdated(MessageEventArgs busEvent); 
<#+
				}
			}
		endBlock();
		}
	}
}

private void DeclareStateMachineClass(Dictionary<System.Xml.XmlElement, List<System.Xml.XmlElement>> stateMachinesByComponent, XmlNodeList publishNodes, XmlNodeList subscribeNodes)
{
	foreach (var element in stateMachinesByComponent)
	{
		var elem = element.Key;
		var component = elem.Attributes["name"].Value;
		foreach (var stateMachine in element.Value)
        {
			var stateMachineType = component+"_"+stateMachine.Attributes["name"].Value + "StateMachine";
			var stateMachineName = component+"_"+stateMachine.Attributes["name"].Value;
#>	public class <#=stateMachineType#> : I<#=stateMachineType#>
	{
<#+
			DeclareSendActionInClass(elem, stateMachine, publishNodes);

			foreach (XmlNode subscribeNode in subscribeNodes)
			{
				var communicationType = subscribeNode.Attributes["communicationType"].InnerText;
				if (communicationType == "IN_MEMORY")
					continue;
				
				var eventName = subscribeNode.Attributes["event"].InnerText;
				var stateMachineCode = subscribeNode.Attributes["stateMachineCode"].Value;
				if (stateMachineCode == stateMachine.Attributes["id"].Value
					&& eventName != string.Empty) 
				{
					var methodName = stateMachine.Attributes["name"].Value; 
#>	
		public event System.Action<<#=eventName#>> <#=methodName#>;
		public void On<#=methodName#>InstanceUpdated(MessageEventArgs busEvent) {
			if( <#=methodName#> != null ){ 
				var publicMember = busEvent.MessageReceived as <#=eventName#>;
				if( publicMember != null ) <#=methodName#>(publicMember);
			}
		}
<#+					
				}
			}
			endBlock();
		}
	}
}


private void DeclareSendActionInClass(System.Xml.XmlElement element, System.Xml.XmlElement stateMachine, XmlNodeList  publishNodes)
{
	List<string> eventCodes = new List<string>() ;
	var component = element.Attributes["name"].Value;
	var stateMachineType = component+"_"+stateMachine.Attributes["name"].Value + "StateMachine";

#>		private readonly IXCPublisher _xcPublisher;
		
		public <#=stateMachineType#>(IXCPublisher publisher)
		{
			_xcPublisher = publisher;
		}
<#+
	foreach (XmlNode publishNode in publishNodes)
	{
		var communicationType = publishNode.Attributes["communicationType"].InnerText;
		if (communicationType == "IN_MEMORY")
			continue;

		if (element.Attributes["id"].Value == publishNode.Attributes["componentCode"].Value)
		{
			var eventName = publishNode.Attributes["event"].InnerText;
			var eventCode = publishNode.Attributes["eventCode"].InnerText;
			var eventNameFirst = (eventName.Split('.')).FirstOrDefault();
			var eventNameSecond = (eventName.Split('.'))[1];
			
			//Check if Event is called once and part of XC.Component.Userobject
			if (!eventCodes.Contains(eventCode) 
				&& eventName != string.Empty 
				&& eventNameFirst == "XComponent" && eventNameSecond != "Common") 
			{
				var eventNameEnd = (eventName.Split('.')).Last();
				eventCodes.Add(eventCode);
				var stateMachineName = stateMachine.Attributes["name"].Value; 
#>		public void Send<#=eventNameEnd#>(<#=eventName#> obj, Visibility visibility)
		{
			_xcPublisher.SendEvent("<#=stateMachineName#>", obj, visibility);
		}
<#+
			}
		}
	}

}

private void DeclareSendActionInInterface(System.Xml.XmlElement element, System.Xml.XmlElement stateMachine, XmlNodeList  publishNodes)
{	
	List<string> eventCodes = new List<string>() ;
	var component = element.Attributes["name"].Value;
	var stateMachineType = component+"_"+stateMachine.Attributes["name"].Value + "StateMachine";

	foreach (XmlNode publishNode in publishNodes)
	{
		var communicationType = publishNode.Attributes["communicationType"].InnerText;
		if (communicationType == "IN_MEMORY")
			continue;

		if (element.Attributes["id"].Value == publishNode.Attributes["componentCode"].Value)
		{
			var eventName = publishNode.Attributes["event"].InnerText;
			var eventCode = publishNode.Attributes["eventCode"].InnerText;
			var eventNameFirst = (eventName.Split('.')).FirstOrDefault();
			var eventNameSecond = (eventName.Split('.'))[1];
			
			//Check if Event is called once and part of XC.Component.Userobject
			if (!eventCodes.Contains(eventCode) 
				&& eventName != string.Empty 
				&& eventNameFirst == "XComponent" && eventNameSecond != "Common") 
			{
				var eventNameEnd = (eventName.Split('.')).Last();
				eventCodes.Add(eventCode);
				var stateMachineName = stateMachine.Attributes["name"].Value; 
#>		void Send<#=eventNameEnd#>(<#=eventName#> obj, Visibility visibility);
<#+
			}
		}
	}
}

private void EndSpaceBlock(){
#>
}
<#+
}
private void endBlock(){
#>
	}
<#+
}
#>